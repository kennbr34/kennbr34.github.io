

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>ken's passmanager</TITLE>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
</HEAD><BODY>
  <H1>ken's passmanager</H1>
  
  
  
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="passmanager-1.24.1.html">YAXA DOCS(for 1.24.1)</A><DD>
<DT><A HREF="#lbAE">DESCRIPTION</A><DD>
<DT><A HREF="#lbAB">DOWNLOAD</A><DD>
<DT><A HREF="#DEPENDENCIES">DEPENDENCIES</A><DD>
<DT><A HREF="#COMPILATION">COMPILATION</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">OPTIONS SUMMARY</A><DD>

<DT><A HREF="#lbAF">MODES</A><DD>
<DL>
<DT><A HREF="#lbAG">Add mode</A><DD>
<DT><A HREF="#lbAH">Read mode</A><DD>
<DT><A HREF="#lbAI">Delete mode</A><DD>
<DT><A HREF="#lbAJ">Update entry mode</A><DD>
<DT><A HREF="#lbAK">Update database mode</A><DD>
</DL>
<DT><A HREF="#lbAL">OPENSSL NOTES</A><DD>
<DL>
<DT><A HREF="#lbAM">Camellia</A><DD>
<DT><A HREF="#lbAN">Reccomended Modes</A><DD>
<DT><A HREF="#lbAO">OpenSSL Ciphers</A><DD>
<DT><A HREF="#lbAP">Key Derivation</A><DD>
<DT><A HREF="#lbAQ">CSPRNG</A><DD>
</DL>
<DT><A HREF="#lbAR">SECURITY DESIGN NOTES</A><DD>
<DL>
<DT><A HREF="#lbAS">Input Padding</A><DD>
<DT><A HREF="#lbAT">Cascaded Encryption Security</A><DD>
<DT><A HREF="#lbAU">Enveloped Encryption Concept</A><DD>
<DT><A HREF="#lbAV">Encryption and Authentication Composition</A><DD>
<DT><A HREF="#lbAW">Temporary Files vs Memory Buffers</A><DD>
</DL>
<DT><A HREF="#lbBC">EXAMPLES</A><DD>
<DT><A HREF="#lbBD">BUGS</A><DD>
<DT><A HREF="#lbBE">REFERENCES</A><DD>
<DT><A HREF="#lbBF">SEE ALSO</A><DD>
</DL>

  <A NAME="lbAE">&nbsp;</A>
<H2>DESCRIPTION</H2>

<P>
passmanager  is an ultra simple, but very secure password management program written in C and making use of OpenSSL's Libcrypto API libraries.  The
passwords can be written, read, updated or deleted from an encrypted database file.  
<P>
<P>
New passwords can be randomly generated when creating or updating account credentials. Passwords  can  be  matched by entry name, and printed/updated/deleted in bulk or individually. All password entries in the database can be updated at once with ease. If the user updated/deleted a password they didn't intend to, the program lists which entries were matched and edited, and provides an automatically produced backup file to restore from. The database password and encryption method can be changed at any time.
<P>
<P>
The program pays special attention to minimize the amount user passwords are displayed on screen or stored in memory, and allows them to be sent directly to the clipboard (via xclip). Allowing the passwords to be sent directly to the clipboard means adding, updating or retrieving a password can be done without it ever being visible on the screen. Even if a user must display an entry's password to verify it, only that pass can be printed, in order to prevent the entire database being displayed on screen.  Authenticated encryption protects the database against both data corruption and tampering.
<P>
<P>
Account credentials are stored with cascading encryption. First 256-bit camellia is used in OFB mode, and then camellia's cipher-text data is further encrypted using OpenSSL's EVP routines. Using OpenSSL's EVP functions also enables the use of any encryption and digest algorithm supported by  the EVP interface.  For example, encryption can be done with blowfish, and the KDF can use the whirlpool digest algorithm.  The default 2nd algorithm in the cascade is 256-bit AES in CTR mode.
<P>
<P>
User input is stored in 512 byte buffers padded by cryptographically strong pseudorandom data: One for an entry's name, and the other for that entry's password.
This allows very large passwords, as well as long and flexible entry names, which can be comprised of service names and account names, and are best
delimited  with a colon. The program will print out each buffer delimited as a colon as well, in a list of &quot;entry name : entry pass&quot; format.  The
format of &quot;entry name&quot; is up to the user.
<P>
<DL COMPACT><DT><DD>
service : account : password
<br>
foobar : foo : passfoo
<br>
gmail : account@gmail.com : (*&amp;*UJD83dh
<P>
</DL>

<P>

But any of these are also possible
<P>
<DL COMPACT><DT><DD>
just a user account : password
<br>
foo - bar : foobar : foobar
<br>
555 867 5309 : (*&amp;*UJD83dh
<P>
</DL>

<P>

With this format and the modes provided, the user can easily and securely manage the contents of the database.
  
<P>
  <A HREF="#index">Back To Index</A>
  <A NAME="lbAB">&nbsp;</A>
<H2>DOWNLOAD</H2>
  
<A HREF="https://github.com/kennbr34/passmanager">GitHub</A>
<br>
<br>
Automake Tarballs:
<br>
<A HREF="https://github.com/kennbr34/passmanager/raw/tarrball/passmanager-2.0.0.tar.gz">2.0.0 tarball - without YAXA (replaed with camellia-256-ofb)</A>
<br>
<A HREF="https://github.com/kennbr34/passmanager/raw/tarrball/passmanager-1.24.1.tar.gz">1.24.1 tarball - with YAXA (homebrewed crypto)</A>
<br>
<br>
C Source Files:
<br>
<A HREF="https://github.com/kennbr34/passmanager/blob/master/src/passmanager.c">passmanager.c - 2.0.0</A>
<br>
<A HREF="https://github.com/kennbr34/passmanager/blob/1.24.1/src/passmanager.c">passmanager.c - 1.24.1</A>
<br>

  <P>
  <A HREF="#index">Back To Index</A>
  
<A NAME="DEPENDENCIES">&nbsp;</A>
<H2>DEPENDENCIES</H2>
<P>
OpenSSL
  <br>
xclip(optional)
<P>
<A HREF="#index">Back To Index</A>
  
<A NAME="COMPILATION">&nbsp;</A>
<H2>COMPILATION</H2>
<P>
Compilation with gcc is simple, just link with '-lcrypto'.
<P>
gcc passmanager.c -o passmanager -lcrypto
  <P>
  <A HREF="#index">Back To Index</A>
 
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<P>

passmanager [<B>-a</B> <I>entry name</I> | <B>-r</B> <I>entry name</I> | <B>-d</B> <I>entry name</I> | <B>-u</B> <I>entry name</I> [-n <I>new name</I> ] | <B>-U</B> ] [-p <I>new entry password</I>] [-l <I>random password length</I>] [-x <I>database password</I>] [-c <I>cipher</I>] [-H <I>digest</I>] [ <B>-P</B> ] <B>-f</B> <I>database file</I> [ <B>-C</B> ] [ <B>-s</B> <I>secondss</I> ]
<P>
<P>
<A HREF="#index">Back To Index</A>
<A NAME="lbAD">&nbsp;</A>
<H2>OPTIONS SUMMARY</H2>

<P>

Options may have different implications depending on operating mode
<P>

<B>-r</B> <I>entry name</I>&nbsp;- Lookup <I>entry name</I> in <B>Read</B> mode ('allpasses' will print all passes)
<P>

<B>-a</B> <I>entry name</I>&nbsp;- Add <I>entry name</I> in <B>Add</B> mode
<P>

<B>-d</B> <I>entry name</I>&nbsp;- Delete <I>entry name</I> in <B>Delete</B> mode
<P>

<B>-u</B> <I>entry name</I>&nbsp;- Update <I>entry name</I> in <B>Update entry</B> mode
<P>

<B>-n</B> <I>new name</I>&nbsp;- entry name up to 512 characters (can contain white space or special characters)
<P>

<B>-U - Update database</B> mode
<P>

<B>-p</B> <I>new entry password</I> - entry password up to 512 characters (don't call to be prompted instead) ('gen' will generate a random password, 'genalpha' will generate a random password with no symbols)
<P>

<B>-l</B> <I>random password length</I> - makes 'gen' or 'genalpha' generate a password <I>random password length</I> digits long (defaults to 16 without this option)
<P>

<B>-x</B> <I>database password</I> - To supply database password as command-line argument (not reccomended)
<P>

<B>-c</B> <I>cipher</I> - Specify 'list' for a list of methods available to OpenSSL. Default: AES-256-CTR.
<P>

<B>-H</B> <I>digest</I> - Specify 'list' for a list of methods available to OpenSSL. Default: SHA512.
<P>

<B>-P</B> - In <I>Update entry</I> or <I>Update database</I>  mode (<B>-u</B> and <B>-U</B> respectively) this option enables updating the <I>entry password</I> or <I>database password</I> via prompt instead of as command line argument
<P>

<B>-f</B> - <I>database file</I> ( must be specified )
<P>

<B>-C</B> - end <I>entry password</I> directly to clipboard. Clipboard is cleared 30 seconds afterward. (needs xclip)
<P>

<B>-s</B> <I>seconds</I> - clear clipboard <I>seconds</I> after instead of default 30
<P>

<B>-h</B> - Quick usage help
<P>

<P>
  <A HREF="#index">Back To Index</A>
<A NAME="lbAF">&nbsp;</A>
<H2>MODES</H2>

<P>

<A NAME="lbAG">&nbsp;</A>
<H3><B>Add mode</B></H3>

<P>

In <B>Add</B> mode the password database is initialized with the first entry, or a new entry is added to an existing password database. The user may specify a cipher and/or digest to use upon initialization of the database.
<P>

When adding a new entry, its password can be sent directly to clipboard.  This is especially useful for generating new passwords, where 'gen' can be given as the <I>entry password</I> argument and the new randomly generated password will be sent to the clipboard.
<P>

Applicable options
<DL COMPACT><DT><DD>
<B>-p</B> <I>new entry password</I> - 'gen' will generate a random password, 'genalpha' will generate a random password with no symbols
<DL COMPACT>
<DT>
<B>-l</B> <I>random password length</I> - makes 'gen' or 'genalpha' generate a password <I>random password length</I> digits long (defaults to 16 without this option)
<DT>
<B>-x</B> <I>database password</I>
<DT>
<B>-c</B> <I>cipher</I> - Initializes a password database with cipher <I>cipher</I>
<DT>
<B>-H</B> <I>digest</I> - Initializes a password database with digest <I>digest</I>.
<DT>
<B>-C</B> send <I>new entry password</I> to clipboard (useful if randomly generated)
<DT>
<B>-s</B> <I>seconds</I> - clear clipboard <I>seconds</I> after instead of default 30
</DL>
</DL>

<P>

<A NAME="lbAH">&nbsp;</A>
<H3><B>Read mode</B></H3>

<P>

<DD>In <B>Read</B> mode the password database is searched for an entry with the name <I>entry name</I> for partial or full matches so that <I>entry name</I> of 'app' will find entry names 'apple' and 'appliances'. 
<P>

Entries can be specifically matched such as &quot;gmail : account1&quot; and &quot;gmail : account2&quot;, or both with 'gmail'.
<P>

Searching for a specific entry pass can be useful to send the password directly to the clipboard using xclip.
<P>

To display the entire password database, enter 'allpasses' for the <I>entry name</I> argument.
<P>

Applicable options
<DL COMPACT><DT><DD>
<B>-x</B> <I>database password</I>
<DL COMPACT>
<DT>
<B>-C</B> send <I>entry name</I> password directly to clipboard (useful to avoid displaying passwords on screen)
<DT>
<B>-s</B> <I>seconds</I> - clear clipboard <I>seconds</I> after instead of default 30
</DL>
</DL>

<P>

<A NAME="lbAI">&nbsp;</A>
<H3><B>Delete mode</B></H3>

<P>

<DD>In <B>Delete</B> mode one or more password entries can be deleted. <I>entry name</I> can be partially or fully matched as in <B>Read</B> mode.
<P>

Applicable options
<DL COMPACT><DT><DD>
<B>-x</B> <I>database password</I>
</DL>

<P>

<A NAME="lbAJ">&nbsp;</A>
<H3><B>Update entry mode</B></H3>

<P>

In <B>Update entry</B> mode one or multiple entries are updated.  As in <B>Read</B> and <B>Add</B> modes, the <I>entry name</I> will be fully or partially matched.
<P>

Both the entry name and password can be updated. The new entry name can be supplied via command line only, but the new password can be received via prompt or as a command line argument ( not recommended ).
<P>

As in <B>Add</B> mode, entering 'gen' for the <I>entry password</I> argument will generate a random password.  This is especially useful for updating old passwords.
<P>
Single new passwords can be sent directly to the clipboard with xclip as well.
<P>
All entries can be updated at once with new randomly generated passwords, if <I>entry name</I> is equal to 'allpasses'
<P>

Applicable options
<DL COMPACT><DT><DD>
<B>-P</B>
updates <I>entry name</I> and <I>entry password</I>, getting <I>new entry password</I> via user input instead of command line (<B>-p</B>)
<DL COMPACT>
<DT>
<B>-p</B> <I>new entry password</I> - update <I>entry name</I> password to <I>new entry password</I>
<DT>
<B>-l</B> <I>random password length</I> - makes 'gen' or 'genalpha' generate a password <I>random password length</I> digits long (defaults to 16 without this option)
<DT>
<B>-n</B> <I>new name</I> - update <I>entry name</I>  to <I>new name</I>. Without this its assumed you're only changing the password of <I>entry name</I>.
<DT>
<B>-x</B> <I>database password</I>
<DT>
<B>-C</B> send <I>new entry password</I> directly to clipboard after updating <I>entry name</I>
<DT>
<B>-s</B> <I>seconds</I> - clear clipboard <I>seconds</I> after instead of default 30
</DL>
</DL>

<P>

<A NAME="lbAK">&nbsp;</A>
<H3><B>Update database mode</B></H3>

<P>

<DD>In <B>Update databse</B> mode the password and the underlying OpenSSL encryption of the database can be updated.
<P>

If option <B>-c</B> or <B>-H</B> given to update the encryption or digest algorithm ( respectively ) then <B>-P</B> is needed to change the database password as well.
<P>

If only option <B>-U</B> is present, then only the password id updated.
<P>

The new password can only be received via prompt, and cannot be given on the command line. However the current <I>database password</I> can still be received with the <B>-x</B> option.
<P>

Applicable options
<DL COMPACT><DT><DD>
<B>-P</B>
updates database password. Read via prompt. Cannot be supplied via commandline.
<DL COMPACT>
<DT>
<B>-x</B> <I>database password</I> (the current database password to decrypt/with)
<DT>
<B>-c</B> <I>cipher</I> - Update to <I>cipher</I>
<DT>
<B>-H</B> <I>digest</I> - Update to <I>digest</I>
</DL>
</DL>
  <A HREF="#index">Back To Index</A>

<P>

<P>
<A NAME="lbAL">&nbsp;</A>
<H2>OPENSSL NOTES</H2>

<P>
<A NAME="lbAM">&nbsp;</A>
<H3>Camellia</H3>

<P>
<DD>Camellia was chosen as the 1st algorithm in the cascade simply because it is certified by the European Union's &quot;NESSIE&quot; and Japan's &quot;CRYPTREC&quot;, and from all cursory research, is comparable to AES. The code can be easily modified to select a differnt algorithm: Simply search for &quot;camellia-256-ofb&quot; and replace it with any valid OpenSSL cipher name. Later versions will make the 1st algorithm selectable by command-line option like the 2nd is.
<P>
<A NAME="lbAN">&nbsp;</A>
<H3>Reccomended Modes</H3>

<P>
<B>Whichever 2nd algorithm is chosen for the cascade, it should be used in OFB or CTR mode.</B>  
<P>
The reason being is that these modes effectively turn block ciphers into stream ciphers, and the reason we would want that in this context is because using two stream ciphers in cascading encryption makes the resulting encryption at least as hard to break as the strongest algorithm.  Otherwise, if a mode like CBC is used, certain chosen plain-text attacks may be feasible to conduct against the 2nd algorithm in the cascade.  One such attack is known as a meet-in-the-middle attack, but as long as the cascaded algorithms are both stream ciphers, this attack is not feasible (Schneier).
<P>
One caveat to using these modes is that the OpenSSL routines don't check for decryption error with them, and so entering an incorrect password will not prompt the user with a &quot;Wrong key&quot; message like other modes would.  Instead, OpenSSL will decrypt the ciphertext with the incorrect key, and then the MAC will fail because the resulting camellia cipher-text will not match what was generated by HMAC. This makes it difficult to distinguish between an incorrect password, and data integrity issues; if you are confident you are entering the correct password, assume it is a data integrity issue.
<P>
<A NAME="lbAO">&nbsp;</A>
<H3>OpenSSL Ciphers</H3>

<P>
The encryption algorithm used by OpenSSL can be chosen between the ciphers provided by the high-level functions in the <I><A HREF="/cgi-bin/man/man2html?3+evp">evp</A>(3)</I> library. By default the program uses 256-bit AES in CTR mode, using the <I><A HREF="/cgi-bin/man/man2html?3+EVP_BytesToKey">EVP_BytesToKey</A>(3)</I> function to derive the key (see <I><A HREF="/cgi-bin/man/man2html?3+EVP_BytesToKey">EVP_BytesToKey</A>(3)</I> for details), and the SHA512 digest algorithm therein. 
<P>
The EVP library provides access to many different blocking modes as well as different cipher algorithms. The choice of which of these respective algorithms to use was made available simply because it was possible to with ease.  For this program's use, AES-256 in CTR mode with SHA512 digests is the strongest configuration available using NIST standards.  Otherwise, blowfish (in OFB) and whirlpool may be an alternative open-source configuration; the rationale to use these could be that both algorithms are slow, so it would make bruteforcing against them slower, or not trusting national encryption standards, etc.  Whatever your rationale for preferring one algorithm over the other, the program will allow it. Just be sure to use it in OFB or CTR mode.
<P>
There are also some exotic digest options such as &quot;RSA encrypted SHA512&quot; which might provide extra security over SHA512 alone.  However, OpenSSL's documentation is not clear on what this entails or how it should be implemented, so it is probably safer to use the more vanilla offerings.
<P>
There are a number of cipher options listed that do not work, for reasons that were not analyzed. Priority wasn't given to making these options function.
<P>
<DL COMPACT><DT><DD>
aes-128-ccm
<P>
aes-128-gcm
<P>
<P>
aes-192-ccm
<P>
aes-192-gcm
<P>
aes-256-ccm
<P>
aes-256-gcm
<P>
des-ede3-cfb1
<P>
id-aes128-wrap
<P>
id-aes192-wrap
<P>
id-aes256-wrap
</DL>

<P>
<A NAME="lbAP">&nbsp;</A>
<H3>Key Derivation</H3>

<P>
The key derivation is done by <I><A HREF="/cgi-bin/man/man2html?3+EVP_BytesToKey">EVP_BytesToKey</A>(3)</I> which is described in detail in <I><A HREF="/cgi-bin/man/man2html?3+EVP_BytesToKey">EVP_BytesToKey</A>(3)</I> and in brief in <I><A HREF="/cgi-bin/man/man2html?3+evp">evp</A>(3)</I>:
<P>
<DL COMPACT><DT><DD>
The EVP_BytesToKey function provides some limited support for password based encryption. Careful selection of the parameters will provide a PKCS#5 PBKDF1 compatible implementation. However, new applications should not typically use this (preferring, for example, PBKDF2 from PCKS#5).
</DL>

<P>
However since the default configuration uses SHA512 instead of MD5, and the digest can be user specified, this means it does not necessarily meet the PBKDF1 standards.  The decision not to use PBKDF2 was made because the EVP library KDF automatically generates appropriate keyring material for the specified ciphers.  Some use IVs and some don't, and some require different key lengths.  The <I><A HREF="/cgi-bin/man/man2html?3+EVP_BytesToKey">EVP_BytesToKey</A>(3)</I> function handles all that automatically.  Meanwhile it could be argued that SHA512 is much more impervious to collisions than MD5 so there's no reason to believe this implementation is less secure than PBKDF1 due to the use of a stronger digest algorithm.
<P>
<A NAME="lbAQ">&nbsp;</A>
<H3>CSPRNG</H3>

<P>
The EVP library also provides access to OpenSSL's CSPRNG as described in <I><A HREF="/cgi-bin/man/man2html?3+RAND">RAND</A>(3)</I>.  The <I><A HREF="/cgi-bin/man/man2html?3+RAND_bytes">RAND_bytes</A>(3)</I> function is what fills the buffers with pseudorandomness, generates random passwords, and generates the salt which generates camellia's nonce as well.
<P>
<A NAME="lbAR">&nbsp;</A>
<H2>SECURITY DESIGN NOTES</H2>

<P>
<A NAME="lbAS">&nbsp;</A>
<H3>Input Padding</H3>

Input buffers will accept any amount of whitespace or special characters up to 512 characters in length.  The buffers are padded with pseudo-random data from a Cryptographically Strong Pseudo Random Number Generator (CSPRNG). This was done with more consideration than simply providing ample memory for user input.
<P>
The extra space being padded with pseudo-random data also helps suppress natural-language frequencies, making frequency analysis of the plain-text less useful. This is because the padding always makes plaintext unique and pseudorandom despite any identical and/or predictable user input.  This also has the effect of lengthening the keystream generated, but without increasing determinism into it with more identical and/or predictable plain-text.
<P>
A different cipher-text will be generated for every password database file, even if it's encrypted with the same password, user input, and even the same salt. This is because plain-text will never be the same even with identical user input, due to the pseudo-random buffer padding.  Of course this only applies to the initialization of the database file; subsequent updates of the same file could have repeatable plain-text, so the use of salts and nonces is still necessary.
<P>
<A NAME="lbAT">&nbsp;</A>
<H3>Cascaded Encryption Security</H3>

<P>
In the classic Alice and Bob model, if Bob does not trust Alice's cipher, he can encrypt his message with his cipher, and then encrypt that cipher-text into a second cipher-text with Alice's cipher.  Alice can then decrypt it using her cipher, and then decrypt the second cipher-text using Bob's cipher.  In this way Bob does not have to trust Alice's cipher, and Alice is unaffected by vulnerabilities in Bob's cipher, and vise versa.  This is most widely known as cascaded encryption.
<P>
The primary purpose of the cascaded encryption in this program, however, is mainly to make the attack on its temporary files less practical than other side-channel attacks. Some argue that a cascaded cipher may be more susceptible to chosen plain-text attacks, notably meet-in-the-middle attacks. However, according to Bruce Schneier in &quot;Applied Cryptography&quot;, that applies mostly to the cipher-block chaining mode. As long as the first and second algorithms in the cascade are both stream ciphers (or implemented in a mode that effectively makes them stream ciphers), then the combination of the two is at least as strong as the strongest algorithm, and not susceptible to meet-in-the-middle attacks.
<P>
Therefore if camellia adds no significant cryptographic strength, then the combination of the two is still at least as strong as the second cipher used. If some vulnerability in camellia was exploited, the cipher-text will only be as vulnerable as the second algorithm used by OpenSSL.  The default implementation uses AES in CTR mode as the 2nd algorithm, effectively making it a stream cipher. That means the password database's encryption will be at least as strong as AES since camellia is implemented in OFB mode, also making it work as a stream cipher. Because OFB and CTR mode make a cipher malleable, the cipher-text generated by camellia is verified by Message Authentication Code generated with a secure HMAC function.
<P>
<A NAME="lbAU">&nbsp;</A>
<H3>Enveloped Encryption Concept</H3>

<P>
This program conceptualizes the cryptographic concept of cascading and authenticated encryption as a figurative analogy involving envelopes. Not to be confused with how OpenSSL uses the concept, which is the name sake for the EVP functions.
<P>
The original plain-text message (the non-encrypted password database) is ran through HMAC-SHA512 to create a Message Authentication Code before being encrypted with the enveloped (first) algorithm, camellia-256-OFB. The camellia cipher-text message and the MAC are then placed together inside of an &quot;envelope&quot;.  Therefore, the program uses two primary functions, <I>openEnvelope()</I> and <I>sealEnvelope()</I> which contain the enveloping (second) algorithm's routines to &quot;seal&quot; the camellia cipher-text message and MAC into an &quot;envelope&quot;, or &quot;open&quot; an envelope containing them.
<P>
<I>sealEnvelope()</I> is used to encrypt the camellia ciphertext with the enveloping (second) algorithm after a database is created or modified.  The plain-text (user input and the padded buffers ) is ran through HMAC-SHA512 before encryption to create the MAC, then the MAC is concatenated to the camellia ciphertext before being passed to <I>sealEnvelope()</I> and encrypted with the enveloping (second) algorithm to form the final password database.  The encrypted password database file can be considered the &quot;envelope&quot; we're opening and sealing. <I>openEnvelope()</I> decrypts the cipher-text data created by OpenSSL (the second, or &quot;enveloping&quot; cipher), checks this with HMAC against the MAC, and if it matches, passes the camellia data to the rest of the program functions for decryption and processing.
<P>
<A NAME="lbAV">&nbsp;</A>
<H3>Encryption and Authentication Composition</H3>

<P>
When using authentication codes, there are three distinct configurations in which one can encrypt and authenticate.  There is Authenticate-and-Encrypt, Authenticate-then-Encrypt, and Encrypt-then-Authenticate.  Must of the consensus on the subject would suggest that Encrypt-then-Authenticate is the most secure method due to theoretical and practical exploitation of the other two methods.
<P>
However, with this implementation of temporary files, the Encrypt-then-Authenticate approach did not prove to protect against simulated chosen-ciphertext attacks.  When spoofed ciphertext was inserted into the temporary files to simulate an attack, the Encrypt-then-Authenticate composition still allowed erroneous ciphertext bits to be inserted and decrypted.  As a more catastrophic result, the changes to the ciphertext were in some cases used to modify the camellia data, and the resulting password database was corrupted.
<P>
Using the Authenticate-and-Encrypt form of composition, spoofing of the ciphertext in the temporary files was detected by the MAC upon decryption of the camellia data, and then no further processing took place.  Therefore the temporary files can be injected with any spoofed data while open, but these changes will not be allowed to corrupt the password database unless the MAC was accurately spoofed, but measures to prevent that are described in the <B>Temporary Files vs Memory Buffers</B> section below.
<P>
The primary flaw of the Authenticate-and-Encrypt format is that the MAC is written to the end of the file unencrypted, potentiating a leak of information about the plain-text if the one-way hash function leaks information.  However, this program uses a secure HMAC function provided by OpenSSL.  As well, there is the obvious fact that the camellia data and MAC will then be encrypted with AES in the final ciphter-text.
<P>
<A NAME="lbAW">&nbsp;</A>
<H3>Temporary Files vs Memory Buffers</H3>

<P>
The program uses temporary files to store and process data, rather than operate solely in memory. camellia-256-OFB prevents that data from being sent to disk in plain-text. Data remanence issues of using temporary files to store the data for processing are obvious, and the Schneier 7-Pass method is used to erase sensitive data from files before exit.  The program cleans up these files, as well as buffers that were storing sensitive information, upon closing or receiving SIGINT or some other error. The temporary files are also protected by the authenticated encryption described above.
<P>
The temporary files are also given a random name that is of a random length, and with read/write permissions only for the file owner.  Despite this, it is still trivial to intercept data from these with elevated priveleges. To mitigate this, authenticated encryption helps protect against man-in-the-middle attacks attempting to spoof cipher-text data on its way from disk to memory. The attacker must be able to predict which random filename contains which data in order to spoof cipher-text and the checksum, and they would have to somehow time and automate such an attack.
<P>
Writing the program to function solely in memory would not necessarily make the program more secure, especially not in respect to any circumstance that would make storing the information to temporary files vulnerable (i.e. an attacker has root access to the machine the program runs on). At best it would only make the information harder to access without a filesystem abstraction; an attacker could write a simple shell script to intercept sensitive data from temp files, but would need to write something more sophisticated to access it from memory buffers. On the other hand, if the information in those temp files is encrypted, suddenly the level of sophistication needed to exploit them goes up.
<P>
With all that in mind, while operating solely in memory may seem much more secure superficially, the vulnerability of leaving the data in temporary files is only relevant in a situation where storage in memory is mutually vulnerable. Even then, camellia protects the secrets of the plain-text, HMAC protects the integrity of the temp files from tampering, and both effectively makes an attack against the temporary files no simpler (and probably much more complicated) than an attack against program memory.
<P>
  <A HREF="#index">Back To Index</A>
<A NAME="lbBC">&nbsp;</A>
<H2>EXAMPLES</H2>

<P>
Initialize a new password database and save it to the file passwords.  Also randomly generate a password of 32 characters for the new entry, and send that new password to the clipboard.
<P>
<DL COMPACT><DT><DD>
passmanager -a &quot;gmail : myemail@gmail.com&quot; -p gen -l 32 -f ./passwords -C
</DL>

<P>
Change the encryption and/or digest used for the password database
<P>
<DL COMPACT><DT><DD>
passmanager -U -c blowfish -H whirlpool -f ./passwords
</DL>

<P>
Print a list of available ciphers
<P>
<DL COMPACT><DT><DD>
passmanager -c list
</DL>

<P>
Print a list of available digests
<P>
<DL COMPACT><DT><DD>
passmanager -H list
</DL>

<P>
Can also change password for the database (Will be prompted for input)
<P>
<DL COMPACT><DT><DD>
passmanager -U -f ./passwords
</DL>

<P>
Or you could do both in one command
<P>
<DL COMPACT><DT><DD>
passmanager -U -c aes-256-cbc -H sha512 -P -f ./passwords
</DL>

<P>
Update the previously added entry name from &quot;gmail : myemail@gmail.com&quot; to &quot;gmail : myemail1@gmail.com&quot; (Note how we're partially matching &quot;gmail&quot;, and the need for quotations around the new entry name since it contains whitespace)
<P>
<DL COMPACT><DT><DD>
passmanager -u gmail -n &quot;gmail : myemail1@gmail.com&quot; -f ./passwords
</DL>

<P>
Add a second gmail account but with the entry password &quot;password&quot;
<P>
<DL COMPACT><DT><DD>
passmanager -a &quot;gmail : myemail2@gmail.com&quot; -p password -f ./passwords
</DL>

<P>
If you are following these examples sequentially, this is how you would print out your password database, and what it would look like on screen.
<P>
<DL COMPACT><DT><DD>
passmanager -r allpasses -f ./passwords
</DL>

<P>
<DL COMPACT><DT><DD>
gmail : myemail1@gmail.com : Us3[Ag1&lt;lRw9%Vj5&gt;La0{Nh4|Kr8$Te7
<P>
gmail : myemail2@gmail.com : password
</DL>

<P>
<P>
To update the password for myemail2@gmail.com with a randomly generated 16 character (default) password, and send the newly created password to clipboard
<P>
<DL COMPACT><DT><DD>
passmanager -u &quot;gmail : myemail2&quot; -p gen -f ./passwords -C
</DL>

<P>
To update the passsword but prompt the user for password
<P>
<DL COMPACT><DT><DD>
passmanager -u &quot;gmail : myemail2&quot; -P -f ./passwords
</DL>

<P>
Read the new password for myemail2@gmail.com and send it directly to the clipboard
<P>
<DL COMPACT><DT><DD>
passmanager -r &quot;gmail : myemail2&quot; -C -f ./passwords
</DL>

<P>
Or to just print both gmail passwords on screen ( but no other entry passwords )
<P>
<DL COMPACT><DT><DD>
passmanager -r gmail -f ./passwords
</DL>

<P>
To delete both of the gmail accounts. (Note no need for quotation marks since we can partially match both entry names before the whitespace portions)
<P>
<DL COMPACT><DT><DD>
passmanager -d gmail -f ./passwords
</DL>

<P>
To print all passwords in database, and supply the database password as a command-line argument (Perhaps to fill in from some other location besides user input)
<P>
<DL COMPACT><DT><DD>
passmanager -r allpasses -f ./passwords -x password
</DL>

<P>
To update all passwords in database with a randomly generated passwords
<P>
<DL COMPACT><DT><DD>
passmanager -u allpasses -p gen -f ./passwords
</DL>

<P>
  <A HREF="#index">Back To Index</A>
<A NAME="lbBD">&nbsp;</A>
<H2>BUGS</H2>

<P>
See <A HREF="#lbAW">YAXA Implementation Flaw</A>
<P>
  <A HREF="#index">Back To Index</A>
<A NAME="lbBE">&nbsp;</A>
<H2>REFERENCES</H2>

<P>
The author consulted several reference sources in order to design and describe the cryptographic function of this program.
<P>
<I>&quot;Applied Cryptography,&quot;</I> Bruce Schneier
<P>
<I>&quot;Serious Cryptography,&quot;</I> Jean-Philippe Aumasson
<P>
<I>&quot;Cryptography Engineering,&quot;</I> Ferguson, Schneier, Kohno
<P>
<I>&quot;Cryptography Theory and Practice 4th Ed,&quot;</I> Stinson, Paterson
<P>
<I>&quot;Handbook of Applied Cryptography,&quot;</I> Alfred J. Menezes
<P>
<A NAME="lbBF">&nbsp;</A>
  <A HREF="#index">Back To Index</A>
<H2>SEE ALSO</H2>

<A HREF="https://www.openssl.org/docs/manmaster/man1/openssl.html">openssl</A>(1), <A HREF="https://linux.die.net/man/1/xclip">xclip</A>(1), <A HREF="https://www.openssl.org/docs/manmaster/man7/crypto.html">crypto</A>(3), <A HREF="https://www.openssl.org/docs/man1.0.2/crypto/evp.html">evp</A>(3), <A HREF="https://www.openssl.org/docs/man1.0.2/crypto/EVP_BytesToKey.html">EVP_BytesToKey</A>(3), <A HREF="https://www.openssl.org/docs/man1.0.2/crypto/EVP_EncryptInit.html">EVP_EncryptInit</A>(3), <A HREF="https://www.openssl.org/docs/man1.1.0/crypto/PKCS5_PBKDF2_HMAC.html">PKCS5_PBKDF2_HMAC</A>(3), <A HREF="https://www.openssl.org/docs/manmaster/man7/RAND.html">RAND</A>(3), <A HREF="https://www.openssl.org/docs/man1.0.2/crypto/RAND_bytes.html">RAND_bytes</A>(3)
<P>
<P>
<P>
<A HREF="#index">Back To Index</A>
</BODY>
</HTML>
